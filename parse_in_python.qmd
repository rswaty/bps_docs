---
title: "parse in python"
format: html
editor: visual
---

## basics

-   need to 'break apart' bps docs into parts so we can reassemble in a database
-   sections are denoted in multiple ways, mostly by **bold** which is a problem as there are bold sections in table
-   some ideas
    -   try to remove all tables then parse by bold

## python to remove tables

```{python}

# Specify the input and output directories
input_directory = 'test_docs/two_docs'
output_directory = 'no_tables2'



import os
from docx import Document

def remove_tables_from_docx(input_file, output_file):
    # Load the document
    doc = Document(input_file)
    
    # Find all tables in the document
    tables = doc.tables
    
    # Iterate over tables in reverse order and delete them
    for table in reversed(tables):
        table._element.getparent().remove(table._element)
    
    # Save the modified document to the output file
    doc.save(output_file)
    print(f"Tables removed and saved to {output_file}")

def process_directory(input_directory, output_directory):
    # Create the output directory if it doesn't exist
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)
    
    # Iterate over all files in the input directory
    for filename in os.listdir(input_directory):
        # Process only .docx files
        if filename.endswith('.docx'):
            input_file = os.path.join(input_directory, filename)
            output_file = os.path.join(output_directory, filename)
            remove_tables_from_docx(input_file, output_file)



# Process the directory
process_directory(input_directory, output_directory)




```

**Looks like it worked!**

## Try to extract most **Bold** components to a dataframe

Components:

Vegetation Type 
Map Zones Model 
Splits or Lumps 
Geographic Range 
Biophysical Site 
Description Vegetation 
Description Disturbance 
Description Scale Description 
Adjacency or Identification Concerns 
Issues or Problems 
Native Uncharacteristic Conditions 
Comments

```{python}
import pandas as pd
import os
from docx import Document

# Define the columns for the DataFrame
columns = [
              "Vegetation Type",
              "Map Zones",
              "Model Splits or Lumps",
              "Geographic Range",
              "Biophysical Site Description",
              "Vegetation Description",
              "Disturbance Description",
              "Scale Description",
              "Adjacency or Identification Concerns",
              "Issues or Problems",
              "Native Uncharacteristic Conditions",
              "Comments"
]

# Define the input directory containing Word documents
input_directory = 'no_tables2'

# Initialize an empty list to store data for each document
data = []

# Iterate over all files in the input directory
for filename in os.listdir(input_directory):
    if filename.endswith(".docx"):
        doc_path = os.path.join(input_directory, filename)
        doc = Document(doc_path)
        
        # Initialize a dictionary to store content for each section
        section_content = {col: "" for col in columns}
        
        # Extract content from each section (based on bold text)
        for para in doc.paragraphs:
            for col in columns:
                if para.text.startswith(col):
                    section_content[col] = para.text[len(col):].strip()
        
        # Append the section content to the data list
        data.append(section_content)

# Create a DataFrame from the collected data
df = pd.DataFrame(data, columns=columns)

# Print the DataFrame
print(df)


```


* empty df

## Get specific sections in R from table-less docs

```{r}
## try to add document names as first column ----

library(officer)
library(dplyr)
library(stringr)

# Define the directory path and sections
directory_path <- "no_tables2/"
sections <- c("Vegetation Type",
              "Map Zones",
              "Model Splits or Lumps",
              "Geographic Range",
              "Biophysical Site Description",
              "Vegetation Description",
              "Disturbance Description",
              "Scale Description",
              "Adjacency or Identification Concerns",
              "Issues or Problems",
              "Native Uncharacteristic Conditions",
              "Comments")

# Function to extract sections from a Word document
extract_sections <- function(doc_path, sections) {
  doc <- read_docx(doc_path)
  paragraphs <- docx_summary(doc)
  
  content_list <- lapply(sections, function(section) {
    section_index <- which(paragraphs$text == section)
    if (length(section_index) == 0) return(NA)
    content <- ""
    for (i in (section_index + 1):nrow(paragraphs)) {
      if (paragraphs$text[i] %in% sections) break
      content <- paste(content, paragraphs$text[i], sep = "\n")
    }
    return(trimws(content))  # Trim leading/trailing whitespace
  })
  
  names(content_list) <- sections
  content_list <- as.data.frame(content_list)
  content_list$document <- basename(doc_path)
  return(content_list)
}

# Get all docx files in the directory
doc_paths <- list.files(directory_path, pattern = "\\.docx$", full.names = TRUE)

# Extract data from each document
data_list <- lapply(doc_paths, function(doc_path) {
  extract_sections(doc_path, sections)
})

# Combine the data into a single dataframe
df <- bind_rows(data_list)

# Move 'document' column to the first position
df <- df %>% select(document, everything())

# Print the dataframe
print(df)

```

This works for the most part.  I want to add an NA into cells where there is no content in the section.  Getting some mismatched content  Or the issue may be empty sections.

Having to ignore these sections:

* BpS Dominant and Indicator Species
* Fire Frequency
* Succession Classes

Will need to add in References

```{r}
library(officer)
library(dplyr)
library(stringr)

# Define the directory path and sections
directory_path <- "no_tables2/"
sections <- c("Vegetation Type",
              "Map Zones",
              "Model Splits or Lumps",
              "Geographic Range",
              "Biophysical Site Description",
              "Vegetation Description",
              "Disturbance Description",
              "Scale Description",
              "Adjacency or Identification Concerns",
              "Issues or Problems",
              "Native Uncharacteristic Conditions",
              "Comments")

# Function to extract sections from a Word document
extract_sections <- function(doc_path, sections) {
  doc <- read_docx(doc_path)
  paragraphs <- docx_summary(doc)
  
  content_list <- lapply(sections, function(section) {
    section_index <- which(paragraphs$text == section)
    if (length(section_index) == 0) return(NA)
    content <- ""
    i <- section_index + 1
    while (i <= nrow(paragraphs)) {
      if (paragraphs$text[i] %in% sections) break
      if (str_detect(paragraphs$text[i], "Succession Classes")) break
      if (str_detect(paragraphs$text[i], "BpS Dominant and Indicator Species")) {
        while (i <= nrow(paragraphs) && !paragraphs$text[i] %in% sections) {
          i <- i + 1
        }
        break
      }
      if (str_detect(paragraphs$text[i], "Fire Frequency")) {
        while (i <= nrow(paragraphs) && !paragraphs$text[i] %in% sections) {
          i <- i + 1
        }
        break
      }
      content <- paste(content, paragraphs$text[i], sep = "\n")
      i <- i + 1
    }
    content <- trimws(content)  # Trim leading/trailing whitespace
    if (content == "") return(NA)  # Return NA if the section is empty
    return(content)
  })
  
  names(content_list) <- sections
  content_list <- as.data.frame(content_list)
  content_list$document <- basename(doc_path)
  return(content_list)
}

# Get all docx files in the directory
doc_paths <- list.files(directory_path, pattern = "\\.docx$", full.names = TRUE)

# Extract data from each document
data_list <- lapply(doc_paths, function(doc_path) {
  extract_sections(doc_path, sections)
})

# Combine the data into a single dataframe
df <- bind_rows(data_list)

# Move 'document' column to the first position
df <- df %>% select(document, everything())

# Print the dataframe
print(df)


```

